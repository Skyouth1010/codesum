/**
 * 
 */
package algorithm.datastructure;

import java.util.TreeMap;

/**
 * 
 * 红黑树特性：根节点和叶子节点是黑色的；红色节点的子节点是黑节点；
 * 每个节点的黑高（到叶结点上的简单路径的黑色节点数）是一样的；
 * 
 * 红黑数是为了保持二叉搜数的平衡，高度为O(lgn);
 * 
 * B树的高度也是O(lgn)，但是底数可以很大，因此实际高度会比红黑数小很多，这大大减少了磁盘读写（由于每次检查一个结点都需要
 * 一次磁盘访问）。B树的结点上可以包含n个关键字（50～2000个），及指向n＋1个子结点的指针。他们都是有序的。
 * 假设B树的最小度数为t（有些地方是阶的概念），则：t-1<= n <= 2t-1，h<=log((n+1)/2) (其中log底数为t)。
 * 
 * B+树（mysql索引数据结构）：所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。
 * 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。
 * 好处：
 * 1、其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。
 * 一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
 * 2、“数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。
 * 正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。
 * 而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）”
 * “B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，
 * 而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。”
 * 
 * B*树（oracle索引数据结构）：
 * B+树的变体，B*树中非根和非叶子结点再增加指向兄弟的指针；B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）
 * 
 * @author skyouth
 * @see http://blog.csdn.net/v_JULY_v/article/details/6530142/
 *
 * 2016年9月11日
 *
 * @see TreeMap
 * 
 */
public class RedBlackTreeMap {

}
